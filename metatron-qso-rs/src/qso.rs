use std::cell::RefCell;

use serde::Serialize;

use crate::dtl::network::DTLResonatorNetwork;
use crate::graph::metatron::{GraphStatistics, MetatronGraph};
use crate::hamiltonian::{MetatronHamiltonian, SpectrumInfo};
use crate::params::QSOParameters;
use crate::quantum::operator::{OperatorMatrix, QuantumOperator};
use crate::quantum::state::{METATRON_DIMENSION, QuantumState};
use crate::quantum_walk::analysis::QuantumWalkBenchmarker;

/// Discrete symmetry group generated by Metatron Cube automorphisms.
#[derive(Clone, Debug, Serialize)]
pub struct SymmetryGroup {
    permutations: Vec<[usize; METATRON_DIMENSION]>,
}

impl Default for SymmetryGroup {
    fn default() -> Self {
        Self::new()
    }
}

impl SymmetryGroup {
    pub fn new() -> Self {
        let identity = identity_permutation();
        let rotation = hexagon_rotation();
        let reflection = hexagon_reflection();

        let mut elements = vec![identity];
        let mut queue = vec![rotation, reflection];

        while let Some(candidate) = queue.pop() {
            if !elements.contains(&candidate) {
                elements.push(candidate);
                for existing in elements.clone() {
                    queue.push(compose(&candidate, &existing));
                    queue.push(compose(&existing, &candidate));
                }
            }
        }

        Self {
            permutations: elements,
        }
    }

    pub fn order(&self) -> usize {
        self.permutations.len()
    }

    pub fn permutations(&self) -> &[[usize; METATRON_DIMENSION]] {
        &self.permutations
    }

    pub fn as_operators(&self) -> Vec<QuantumOperator> {
        self.permutations
            .iter()
            .filter_map(|perm| QuantumOperator::from_permutation(&perm[..]).ok())
            .collect()
    }

    pub fn is_invariant(&self, matrix: &OperatorMatrix, tol: f64) -> bool {
        for perm in &self.permutations {
            let transformed = conjugate(matrix, perm);
            if !approx_eq_matrix(matrix, &transformed, tol) {
                return false;
            }
        }
        true
    }
}

fn identity_permutation() -> [usize; METATRON_DIMENSION] {
    let mut perm = [0usize; METATRON_DIMENSION];
    for (i, item) in perm.iter_mut().enumerate().take(METATRON_DIMENSION) {
        *item = i;
    }
    perm
}

fn hexagon_rotation() -> [usize; METATRON_DIMENSION] {
    let mut perm = identity_permutation();
    perm[1] = 2;
    perm[2] = 3;
    perm[3] = 4;
    perm[4] = 5;
    perm[5] = 6;
    perm[6] = 1;
    perm
}

fn hexagon_reflection() -> [usize; METATRON_DIMENSION] {
    let mut perm = identity_permutation();
    perm[2] = 6;
    perm[6] = 2;
    perm[3] = 5;
    perm[5] = 3;
    perm
}

fn compose(
    a: &[usize; METATRON_DIMENSION],
    b: &[usize; METATRON_DIMENSION],
) -> [usize; METATRON_DIMENSION] {
    let mut result = [0usize; METATRON_DIMENSION];
    for i in 0..METATRON_DIMENSION {
        result[i] = a[b[i]];
    }
    result
}

fn conjugate(matrix: &OperatorMatrix, perm: &[usize; METATRON_DIMENSION]) -> OperatorMatrix {
    let mut permuted = OperatorMatrix::zeros();
    for i in 0..METATRON_DIMENSION {
        for j in 0..METATRON_DIMENSION {
            let row = perm[i];
            let col = perm[j];
            permuted[(i, j)] = matrix[(row, col)];
        }
    }
    permuted
}

fn approx_eq_matrix(a: &OperatorMatrix, b: &OperatorMatrix, tol: f64) -> bool {
    a.iter().zip(b.iter()).all(|(x, y)| (*x - *y).norm() < tol)
}

/// Summary report of the full QSO analysis pipeline.
#[derive(Clone, Debug, Serialize)]
pub struct QSOReport {
    pub graph: GraphStatistics,
    pub spectrum: SpectrumInfo,
    pub symmetry_order: usize,
    pub synchronization_threshold: f64,
}

/// High-level orchestrator that couples quantum, graph, and DTL subsystems.
pub struct QuantumStateOperator {
    params: QSOParameters,
    graph: MetatronGraph,
    hamiltonian: MetatronHamiltonian,
    symmetry: SymmetryGroup,
    resonators: RefCell<DTLResonatorNetwork>,
}

impl QuantumStateOperator {
    /// Construct the complete hybrid system.
    pub fn new(params: QSOParameters) -> Self {
        let graph = MetatronGraph::new();
        let hamiltonian = MetatronHamiltonian::new(&graph, &params);
        let symmetry = SymmetryGroup::new();
        let resonators = DTLResonatorNetwork::new(graph.clone(), params.clone());

        Self {
            params,
            graph,
            hamiltonian,
            symmetry,
            resonators: RefCell::new(resonators),
        }
    }

    pub fn graph(&self) -> &MetatronGraph {
        &self.graph
    }

    pub fn hamiltonian(&self) -> &MetatronHamiltonian {
        &self.hamiltonian
    }

    pub fn symmetry_group(&self) -> &SymmetryGroup {
        &self.symmetry
    }

    pub fn parameters(&self) -> &QSOParameters {
        &self.params
    }

    pub fn create_state(&self, amplitudes: &[num_complex::Complex64]) -> QuantumState {
        QuantumState::try_new(amplitudes, true).expect("invalid amplitudes")
    }

    pub fn basis_state(&self, index: usize) -> QuantumState {
        QuantumState::basis_state(index).expect("invalid basis index")
    }

    pub fn ground_state(&self) -> QuantumState {
        self.hamiltonian.ground_state()
    }

    pub fn evolve_state(&self, state: &QuantumState, time: f64) -> QuantumState {
        self.hamiltonian.evolve_state(state, time)
    }

    pub fn simulate_resonators(
        &self,
        t_span: (f64, f64),
        dt: f64,
    ) -> (Vec<f64>, Vec<[f64; METATRON_DIMENSION]>) {
        self.resonators.borrow_mut().integrate(t_span, dt)
    }

    pub fn quantum_to_dtl(&self, state: &QuantumState) -> [f64; METATRON_DIMENSION] {
        let mut values = [0.0; METATRON_DIMENSION];
        for (i, probability) in state.probabilities().iter().enumerate() {
            values[i] = *probability;
        }
        values
    }

    pub fn analyze(&self) -> QSOReport {
        let graph_stats = self.graph.statistics();
        let spectrum = self.hamiltonian.spectrum_info();
        let synchronization_threshold = self.resonators.borrow().synchronization_threshold();

        QSOReport {
            graph: graph_stats,
            spectrum,
            symmetry_order: self.symmetry.order(),
            synchronization_threshold,
        }
    }

    /// Verify that the Hamiltonian is invariant under stored symmetry operations.
    pub fn verify_hamiltonian_symmetry(&self, tol: f64) -> bool {
        let matrix = self.hamiltonian.matrix();
        let complex_matrix =
            OperatorMatrix::from_fn(|i, j| num_complex::Complex64::new(matrix[(i, j)], 0.0));
        self.symmetry.is_invariant(&complex_matrix, tol)
    }

    /// Construct a benchmarking harness bound to this QSO instance.
    pub fn quantum_walk_benchmarker(&self) -> QuantumWalkBenchmarker<'_> {
        QuantumWalkBenchmarker::new(self)
    }
}

// TODO: incorporate full automorphism group enumeration using `petgraph` algorithms.
// TODO: expose hooks for hardware backends (photonic or superconducting control layers).
